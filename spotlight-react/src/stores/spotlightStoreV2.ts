import { create } from 'zustand';
import type { Landmark } from '../services/landmarks';

// Agent theme colors - Warm Editorial Palette
export const AGENT_COLORS = {
  'best-overall': { primary: '#8B4513', secondary: '#A0522D', accent: '#C45830' }, // Terracotta
  adventure: { primary: '#3A6247', secondary: '#4A7C59', accent: '#4A7C59' }, // Earthy green
  culture: { primary: '#8B6914', secondary: '#A87600', accent: '#D4A853' }, // Golden
  food: { primary: '#8B3A3A', secondary: '#A04040', accent: '#B54A4A' }, // Brick red
  'hidden-gems': { primary: '#3A7284', secondary: '#4A90A4', accent: '#4A90A4' }, // Mediterranean blue
  scenic: { primary: '#3A6247', secondary: '#4A7C59', accent: '#4A7C59' }, // Earthy green
  'photo-stops': { primary: '#8B6914', secondary: '#A87600', accent: '#D4A853' } // Golden
};

export interface CityCoordinates {
  lat: number;
  lng: number;
}

export interface CityObject {
  name: string;
  country: string;
  coordinates: CityCoordinates;
}

export interface LandmarkStop {
  id: string;
  name: string;
  coordinates: CityCoordinates;
  description?: string;
  detourKm?: number;
  detourMinutes?: number;
  insertAfterCityIndex?: number;
}

// Travel style options
export type TravelStyle = 'explorer' | 'relaxer' | 'culture' | 'adventurer' | 'foodie';

// Dining style options
export type DiningStyle = 'street' | 'casual' | 'mix' | 'fine';

// Accommodation preference options
export type AccommodationStyle = 'budget' | 'mid' | 'luxury' | 'unique';

// Budget level for personalization
export type PersonalizationBudget = 'budget' | 'mid' | 'luxury';

// Trip occasion options
export type TripOccasion =
  | 'honeymoon'
  | 'anniversary'
  | 'birthday'
  | 'graduation'
  | 'retirement'
  | 'babymoon'
  | 'reunion'
  | 'solo-adventure'
  | 'girls-trip'
  | 'guys-trip'
  | 'family-vacation'
  | 'just-because';

// Interest categories for trip personalization
export type PersonalizationInterest =
  | 'history'
  | 'art'
  | 'architecture'
  | 'nature'
  | 'food'
  | 'wine'
  | 'nightlife'
  | 'shopping'
  | 'photography'
  | 'adventure'
  | 'wellness'
  | 'local-culture'
  | 'beaches'
  | 'mountains'
  | 'museums';

// Match reason from personalization scoring
export interface MatchReason {
  factor: string;           // e.g., 'interest_art', 'occasion_honeymoon', 'dining_fine'
  contribution: number;     // Score contribution (0-20 typically)
  explanation: string;      // Human-readable: "Perfect for art lovers"
}

// Activity/Restaurant with match information
export interface PlaceWithMatch {
  matchReasons?: MatchReason[];
  matchScore?: number;      // 0-100 personalization match percentage
}

// Personalization data for deeply customized routes
export interface TripPersonalization {
  // Free-form context from user
  tripStory: string;

  // Travel style (single select)
  travelStyle?: TravelStyle;

  // Pace (1-5 scale: 1 = very relaxed, 5 = packed)
  pace?: number;

  // Interests (multi-select)
  interests?: PersonalizationInterest[];

  // Dining preferences
  diningStyle?: DiningStyle;
  dietary?: string[];

  // Accommodation preference
  accommodation?: AccommodationStyle;

  // Budget level
  budget?: PersonalizationBudget;

  // Accessibility needs (multi-select)
  accessibility?: string[];

  // Trip occasion
  occasion?: TripOccasion;

  // Additional preferences
  avoidCrowds?: boolean;
  preferOutdoor?: boolean;
}

// Activity type with personalization match data
export interface Activity extends PlaceWithMatch {
  name: string;
  description?: string;
  type?: string;
  duration?: string;
  rating?: number;
  priceLevel?: number;
  coordinates?: CityCoordinates;
  photoUrl?: string;
  placeId?: string;
  [key: string]: any;
}

// Restaurant type with personalization match data
export interface Restaurant extends PlaceWithMatch {
  name: string;
  description?: string;
  cuisine?: string;
  rating?: number;
  priceLevel?: number;
  coordinates?: CityCoordinates;
  photoUrl?: string;
  placeId?: string;
  [key: string]: any;
}

export interface CityData {
  city: string | CityObject;
  coordinates: CityCoordinates;
  nights: number;
  activities?: Activity[];
  restaurants?: Restaurant[];
  accommodation?: any[];
  practicalInfo?: any;
  weather?: any;
  events?: any[];
  agentData?: Record<string, any>;
}

// Personalized intro generated by AI
export interface PersonalizedIntro {
  headline: string;          // "Your Honeymoon Adventure Awaits"
  subheadline: string;       // "5 days of romance across Portugal"
  narrative: string;         // 2-3 sentence story about the trip
  highlights: string[];      // Key things to expect
  personalizedFor?: string[];// What preferences shaped this: ["art lover", "romantic getaway"]
}

// Trip style visualization data
export interface TripStyleProfile {
  cultural: number;          // 0-100
  adventure: number;
  relaxation: number;
  culinary: number;
  nature: number;
}

export interface SpotlightRoute {
  id?: string;
  origin: string | CityObject;
  destination: string | CityObject;
  budget?: string;
  agent: string;
  cities: CityData[];
  landmarks: LandmarkStop[];
  nightAllocations: Record<string, number>;
  totalDistance?: number;
  totalDuration?: number;
  routeGeometry?: any;
  routeData?: any; // JSONB data from backend including persisted landmarks
  agentResults?: Array<{
    agent: string;
    recommendations: string;
    metrics: Record<string, any>;
  }>;
  // Personalization data from user input
  personalization?: TripPersonalization;
  // AI-generated personalized content (Sprint 2)
  personalizedIntro?: PersonalizedIntro;
  tripStyleProfile?: TripStyleProfile;
  tripNarrative?: string;    // Full trip story generated by AI
}

interface SpotlightStoreV2 {
  // Core route data
  route: SpotlightRoute | null;

  // UI state
  selectedCityIndex: number | null;
  isAddingLandmark: boolean;
  isEditingCity: boolean;
  isDragging: boolean;

  // Map state
  mapCenter: [number, number] | null;
  mapZoom: number;
  hoveredMarker: string | null;

  // Loading states
  isCalculatingDetour: boolean;
  isLoadingRoute: boolean;

  // Actions
  setRoute: (route: SpotlightRoute) => void;
  updateCities: (cities: CityData[]) => void;
  addLandmark: (landmark: LandmarkStop) => void;
  addLandmarkToRoute: (landmark: Landmark) => Promise<void>;
  removeLandmark: (landmarkId: string) => void;
  updateLandmark: (landmarkId: string, updates: Partial<LandmarkStop>) => void;
  reorderCities: (oldIndex: number, newIndex: number) => void;
  updateCityNights: (cityName: string, nights: number) => void;

  // UI actions
  setSelectedCity: (index: number | null) => void;
  setIsAddingLandmark: (isAdding: boolean) => void;
  setIsEditingCity: (isEditing: boolean) => void;
  setIsDragging: (isDragging: boolean) => void;
  setMapCenter: (center: [number, number] | null) => void;
  setMapZoom: (zoom: number) => void;
  setHoveredMarker: (markerId: string | null) => void;

  // Animation triggers (used by companion to animate map)
  pendingFlyTo: { center: [number, number]; zoom?: number } | null;
  triggerFlyTo: (center: [number, number], zoom?: number) => void;
  clearFlyTo: () => void;
  focusCityByName: (cityName: string) => void;

  // Loading actions
  setIsCalculatingDetour: (isCalculating: boolean) => void;
  setIsLoadingRoute: (isLoading: boolean) => void;

  // Helper methods
  getCityName: (city: string | CityObject) => string;
  getCityCoordinates: (city: string | CityObject) => CityCoordinates | null;
  getAgentColors: () => { primary: string; secondary: string; accent: string };
}

export const useSpotlightStoreV2 = create<SpotlightStoreV2>((set, get) => ({
  // Initial state
  route: null,
  selectedCityIndex: null,
  isAddingLandmark: false,
  isEditingCity: false,
  isDragging: false,
  mapCenter: null,
  mapZoom: 6,
  hoveredMarker: null,
  isCalculatingDetour: false,
  isLoadingRoute: false,
  pendingFlyTo: null,

  // Core actions
  setRoute: (route) => {
    // If route has routeData with landmarks, merge them into the route object
    if (route && route.routeData && route.routeData.landmarks) {
      route.landmarks = route.routeData.landmarks;
      console.log(`ðŸ“¥ Loaded ${route.landmarks.length} landmarks from database`);
    }
    set({ route, isLoadingRoute: false });
  },

  updateCities: (cities) => set((state) => ({
    route: state.route ? { ...state.route, cities } : null
  })),

  addLandmark: (landmark) => set((state) => ({
    route: state.route
      ? { ...state.route, landmarks: [...state.route.landmarks, landmark] }
      : null
  })),

  addLandmarkToRoute: async (landmark) => {
    const state = get();
    if (!state.route) {
      console.error('No route available');
      return;
    }

    set({ isCalculatingDetour: true });

    try {
      console.log('ðŸŽ¯ Adding landmark to route:', landmark.name);

      // Find optimal insertion point (between which two cities)
      const cities = state.route.cities;
      console.log('Cities in route:', cities.length);

      let bestInsertIndex = 0;
      let minDetour = Infinity;

      // Helper function to calculate Haversine distance
      const calculateDistance = (coord1: CityCoordinates, coord2: CityCoordinates): number => {
        const R = 6371; // Earth's radius in km
        const dLat = (coord2.lat - coord1.lat) * Math.PI / 180;
        const dLng = (coord2.lng - coord1.lng) * Math.PI / 180;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(coord1.lat * Math.PI / 180) *
          Math.cos(coord2.lat * Math.PI / 180) *
          Math.sin(dLng / 2) * Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      };

      // Calculate detour for each possible insertion point
      for (let i = 0; i < cities.length - 1; i++) {
        // Use the existing coordinates directly from city data
        const city1Coords = cities[i].coordinates;
        const city2Coords = cities[i + 1].coordinates;

        console.log(`Checking between city ${i} and ${i+1}:`, city1Coords, city2Coords);

        // Validate coordinates
        if (!city1Coords || !city2Coords) {
          console.warn(`Missing coordinates for cities ${i} or ${i+1}`);
          continue;
        }

        const landmarkCoords = { lat: landmark.lat, lng: landmark.lng };

        // Calculate direct distance between cities
        const directDistance = calculateDistance(city1Coords, city2Coords);

        // Calculate detour: city1 -> landmark -> city2
        const detourDistance =
          calculateDistance(city1Coords, landmarkCoords) +
          calculateDistance(landmarkCoords, city2Coords);

        const detourKm = detourDistance - directDistance;
        console.log(`Detour between cities ${i}-${i+1}: ${detourKm.toFixed(1)} km`);

        if (detourKm < minDetour) {
          minDetour = detourKm;
          bestInsertIndex = i;
        }
      }

      // Create landmark stop with detour info
      const landmarkStop: LandmarkStop = {
        id: `landmark-${Date.now()}`,
        name: landmark.name,
        coordinates: { lat: landmark.lat, lng: landmark.lng },
        description: landmark.description,
        detourKm: minDetour === Infinity ? 0 : minDetour,
        detourMinutes: minDetour === Infinity ? 0 : Math.round(minDetour / 80 * 60),
        insertAfterCityIndex: bestInsertIndex
      };

      console.log('ðŸ“ Best insertion point:', bestInsertIndex, 'with detour:', minDetour === Infinity ? 'N/A' : `${minDetour.toFixed(1)} km`);

      // Add landmark to route
      set((state) => {
        const newRoute = state.route
          ? { ...state.route, landmarks: [...state.route.landmarks, landmarkStop] }
          : null;
        console.log('ðŸ“¦ Updating store with new route. New landmarks count:', newRoute?.landmarks.length);
        return { route: newRoute };
      });

      // Read back from store to verify
      const updatedState = get();
      console.log(`âœ… Added ${landmark.name} to route! Verified landmarks in store:`, updatedState.route?.landmarks.length);
      console.log('Landmark IDs in store:', updatedState.route?.landmarks.map(l => l.id));

      // Save landmarks to backend if route has an ID
      if (updatedState.route?.id) {
        try {
          const apiUrl = import.meta.env.VITE_API_URL || '';

          // Add authentication token
          const token = localStorage.getItem('token');
          const headers: HeadersInit = {
            'Content-Type': 'application/json',
          };
          if (token) {
            headers['Authorization'] = `Bearer ${token}`;
          }

          // Add timeout to prevent hanging
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

          console.log(`ðŸ’¾ Saving landmarks to backend for route ${updatedState.route.id}...`);
          const response = await fetch(`${apiUrl}/api/routes/${updatedState.route.id}/landmarks`, {
            method: 'PUT',
            headers,
            body: JSON.stringify({
              landmarks: updatedState.route.landmarks
            }),
            signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (response.ok) {
            console.log('âœ… Landmarks saved to backend successfully');
          } else {
            console.warn('âš ï¸ Failed to save landmarks to backend:', response.status, response.statusText);

            // If backend save failed with 401/403/404, route doesn't exist in DB - save to localStorage instead
            if (response.status === 401 || response.status === 403 || response.status === 404) {
              console.warn('   â†’ Falling back to localStorage (route not in database)');
              try {
                const spotlightDataStr = localStorage.getItem('spotlightData');
                if (spotlightDataStr) {
                  const spotlightData = JSON.parse(spotlightDataStr);
                  spotlightData.landmarks = updatedState.route!.landmarks;
                  localStorage.setItem('spotlightData', JSON.stringify(spotlightData));
                  console.log('   âœ… Landmarks saved to localStorage as fallback');
                } else {
                  console.warn('   âš ï¸ No spotlightData in localStorage to update');
                }
              } catch (err) {
                console.error('   âŒ Failed to save landmarks to localStorage:', err);
              }
            }
          }
        } catch (apiError) {
          if ((apiError as Error).name === 'AbortError') {
            console.warn('âš ï¸ Landmark save timed out after 10 seconds');
          } else {
            console.warn('âš ï¸ Could not save landmarks to backend:', apiError);
          }
          // Fallback to localStorage for any network errors
          console.warn('   â†’ Falling back to localStorage (network error)');
          try {
            const spotlightDataStr = localStorage.getItem('spotlightData');
            if (spotlightDataStr) {
              const spotlightData = JSON.parse(spotlightDataStr);
              spotlightData.landmarks = updatedState.route!.landmarks;
              localStorage.setItem('spotlightData', JSON.stringify(spotlightData));
              console.log('   âœ… Landmarks saved to localStorage as fallback');
            }
          } catch (err) {
            console.error('   âŒ Failed to save landmarks to localStorage:', err);
          }
          // Don't throw - landmark is still in local state
        }
      } else {
        // Route has no database ID - save to localStorage instead
        console.warn('âš ï¸ Route has no database ID. Saving landmarks to localStorage instead.');
        if (!updatedState.route) {
          console.error('   âŒ Cannot save to localStorage: route is null');
          return;
        }
        try {
          const spotlightDataStr = localStorage.getItem('spotlightData');
          if (spotlightDataStr) {
            const spotlightData = JSON.parse(spotlightDataStr);
            spotlightData.landmarks = updatedState.route.landmarks;
            localStorage.setItem('spotlightData', JSON.stringify(spotlightData));
            console.log('âœ… Landmarks saved to localStorage for unsaved route');
          } else {
            console.warn('   âš ï¸ No spotlightData in localStorage to update');
          }
        } catch (err) {
          console.error('   âŒ Failed to save landmarks to localStorage:', err);
        }
      }

    } catch (error) {
      console.error('âŒ Failed to add landmark to route:', error);
      throw error;
    } finally {
      console.log('ðŸ Finished addLandmarkToRoute');
      set({ isCalculatingDetour: false });
    }
  },

  removeLandmark: async (landmarkId) => {
    const state = get();
    if (!state.route) return;

    // Remove from local state
    const newLandmarks = state.route.landmarks.filter(l => l.id !== landmarkId);
    set((state) => ({
      route: state.route
        ? { ...state.route, landmarks: newLandmarks }
        : null
    }));

    // Save to backend if route has an ID
    if (state.route.id) {
      try {
        const apiUrl = import.meta.env.VITE_API_URL || '';

        // Add authentication token
        const token = localStorage.getItem('token');
        const headers: HeadersInit = {
          'Content-Type': 'application/json',
        };
        if (token) {
          headers['Authorization'] = `Bearer ${token}`;
        }

        const response = await fetch(`${apiUrl}/api/routes/${state.route.id}/landmarks`, {
          method: 'PUT',
          headers,
          body: JSON.stringify({
            landmarks: newLandmarks
          })
        });

        if (response.ok) {
          console.log('ðŸ’¾ Landmark removal saved to backend');
        } else {
          console.warn('âš ï¸ Failed to save landmark removal to backend:', response.status, response.statusText);

          // If backend save failed with 401/403/404, route doesn't exist in DB - save to localStorage instead
          if (response.status === 401 || response.status === 403 || response.status === 404) {
            console.warn('   â†’ Falling back to localStorage (route not in database)');
            try {
              const spotlightDataStr = localStorage.getItem('spotlightData');
              if (spotlightDataStr) {
                const spotlightData = JSON.parse(spotlightDataStr);
                spotlightData.landmarks = newLandmarks;
                localStorage.setItem('spotlightData', JSON.stringify(spotlightData));
                console.log('   âœ… Landmark removal saved to localStorage as fallback');
              }
            } catch (err) {
              console.error('   âŒ Failed to save landmark removal to localStorage:', err);
            }
          }
        }
      } catch (error) {
        console.warn('âš ï¸ Could not save landmark removal to backend:', error);
        // Fallback to localStorage for any network errors
        console.warn('   â†’ Falling back to localStorage (network error)');
        try {
          const spotlightDataStr = localStorage.getItem('spotlightData');
          if (spotlightDataStr) {
            const spotlightData = JSON.parse(spotlightDataStr);
            spotlightData.landmarks = newLandmarks;
            localStorage.setItem('spotlightData', JSON.stringify(spotlightData));
            console.log('   âœ… Landmark removal saved to localStorage as fallback');
          }
        } catch (err) {
          console.error('   âŒ Failed to save landmark removal to localStorage:', err);
        }
      }
    } else {
      // Route has no database ID - save to localStorage instead
      console.warn('âš ï¸ Route has no database ID. Saving landmark removal to localStorage instead.');
      try {
        const spotlightDataStr = localStorage.getItem('spotlightData');
        if (spotlightDataStr) {
          const spotlightData = JSON.parse(spotlightDataStr);
          spotlightData.landmarks = newLandmarks;
          localStorage.setItem('spotlightData', JSON.stringify(spotlightData));
          console.log('âœ… Landmark removal saved to localStorage for unsaved route');
        }
      } catch (err) {
        console.error('âŒ Failed to save landmark removal to localStorage:', err);
      }
    }
  },

  updateLandmark: (landmarkId, updates) => set((state) => ({
    route: state.route
      ? {
          ...state.route,
          landmarks: state.route.landmarks.map(l =>
            l.id === landmarkId ? { ...l, ...updates } : l
          )
        }
      : null
  })),

  reorderCities: (oldIndex, newIndex) => set((state) => {
    if (!state.route) return state;

    const cities = [...state.route.cities];
    const [removed] = cities.splice(oldIndex, 1);
    cities.splice(newIndex, 0, removed);

    return {
      route: { ...state.route, cities }
    };
  }),

  updateCityNights: (cityName, nights) => set((state) => {
    if (!state.route) return state;

    const nightAllocations = {
      ...state.route.nightAllocations,
      [cityName]: nights
    };

    const cities = state.route.cities.map(city => {
      const name = get().getCityName(city.city);
      if (name === cityName) {
        return { ...city, nights };
      }
      return city;
    });

    return {
      route: { ...state.route, cities, nightAllocations }
    };
  }),

  // UI actions
  setSelectedCity: (index) => set({ selectedCityIndex: index }),
  setIsAddingLandmark: (isAdding) => set({ isAddingLandmark: isAdding }),
  setIsEditingCity: (isEditing) => set({ isEditingCity: isEditing }),
  setIsDragging: (isDragging) => set({ isDragging: isDragging }),
  setMapCenter: (center) => set({ mapCenter: center }),
  setMapZoom: (zoom) => set({ mapZoom: zoom }),
  setHoveredMarker: (markerId) => set({ hoveredMarker: markerId }),

  // Animation triggers (used by companion to animate map)
  triggerFlyTo: (center, zoom = 10) => set({ pendingFlyTo: { center, zoom } }),
  clearFlyTo: () => set({ pendingFlyTo: null }),
  focusCityByName: (cityName) => {
    const state = get();
    if (!state.route?.cities) return;

    // Find city by name (case insensitive)
    const cityIndex = state.route.cities.findIndex(city => {
      const name = typeof city.city === 'object' ? city.city.name : city.city;
      return name.toLowerCase() === cityName.toLowerCase();
    });

    if (cityIndex === -1) return;

    const city = state.route.cities[cityIndex];
    const coords = city.coordinates;

    if (coords) {
      // Select the city and trigger fly animation
      set({
        selectedCityIndex: cityIndex,
        pendingFlyTo: { center: [coords.lng, coords.lat], zoom: 12 }
      });
    }
  },

  // Loading actions
  setIsCalculatingDetour: (isCalculating) => set({ isCalculatingDetour: isCalculating }),
  setIsLoadingRoute: (isLoading) => set({ isLoadingRoute: isLoading }),

  // Helper methods
  getCityName: (city) => {
    if (typeof city === 'string') return city;
    return city?.name || 'Unknown';
  },

  getCityCoordinates: (city) => {
    if (typeof city === 'string') return null;

    const coords = city?.coordinates;
    if (!coords) return null;

    // If coordinates is an array [lat, lng]
    if (Array.isArray(coords)) {
      return {
        lat: typeof coords[0] === 'number' ? coords[0] : 0,
        lng: typeof coords[1] === 'number' ? coords[1] : 0
      };
    }

    // If coordinates is already an object {lat, lng}
    if (typeof coords === 'object' && 'lat' in coords && 'lng' in coords) {
      return coords;
    }

    return null;
  },

  getAgentColors: () => {
    const state = get();
    const agent = state.route?.agent || 'best-overall';
    return AGENT_COLORS[agent as keyof typeof AGENT_COLORS] || AGENT_COLORS['best-overall'];
  }
}));
